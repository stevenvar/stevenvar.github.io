(* generated by Ott 0.28 from: checker.ott syntax.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import Ott.ott_list_core.


Require Import Ascii.
Require Import String.

Create HintDb ott_coq_equality.

Lemma eq_bool: forall (x y : bool), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_bool : ott_coq_equality.

Lemma eq_ascii: forall (x y : ascii), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_ascii : ott_coq_equality.



Definition n := nat.
Definition identifier := string.
Lemma eq_identifier: forall (x y : identifier), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_identifier : ott_coq_equality.
Definition type_constr := string.
Lemma eq_type_constr: forall (x y : type_constr), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_type_constr : ott_coq_equality.
Definition ocaml_expr := string.
Lemma eq_ocaml_expr: forall (x y : ocaml_expr), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_ocaml_expr : ott_coq_equality.
Definition h := string.
Lemma eq_h: forall (x y : h), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_h : ott_coq_equality.

Inductive unop : Set :=  (*r unary operator *)
 | Unopminus : unop (*r int opposite *)
 | Unopminusf : unop (*r float opposite *)
 | Unopnot : unop (*r negation *).

Inductive constant : Set :=  (*r constants *)
 | Kint : constant
 | Kfloat : constant
 | Kbool : constant.

Inductive binop : Set :=  (*r binary operator *)
 | Binopop_int : binop
 | Binopop_float : binop
 | Binopop_compare : binop
 | Binopop_bool : binop.

Inductive ck : Set :=  (*r clocks *)
 | Ckbase : ck (*r base clock *)
 | Ckon (ck5:ck) (x:identifier) (*r positive subclock *)
 | Ckonnot (ck5:ck) (x:identifier) (*r negative subclock *)
 | Cktuple (ck5:ck) (ck':ck) (*r tuple *)
 | Ckarrow (ck5:ck) (ck':ck) (*r function *).

Inductive e : Set :=  (*r expressions *)
 | Eunit (ck5:ck) (*r unit value *)
 | Econst (k:constant) (ck5:ck) (*r constant *)
 | Evar (x:identifier) (*r variable *)
 | Econstructor (X:type_constr) (ck5:ck) (*r type constructor *)
 | Ebinop (e5:e) (binop5:binop) (e':e) (*r binary operator *)
 | Eunop (unop5:unop) (e5:e) (*r unary operator *)
 | Ewhen (e5:e) (x:identifier) (*r positive sampling *)
 | Ewhennot (e5:e) (x:identifier) (*r negative sampling *).

Inductive cexp : Set :=  (*r control expression *)
 | Ceexp (e5:e) (*r expression *)
 | Cemerge (x:identifier) (ce:cexp) (ce':cexp) (*r merging *)
 | Ceif (e5:e) (ce:cexp) (ce':cexp) (*r alternative *).

Inductive xs : Set :=  (*r noms de variables *)
 | Patp_nil : xs (*r empty/unit pattern *)
 | Patp_var (y:identifier) (*r variable pattern *)
 | Patp_tuple (y:identifier) (ys:xs) (*r tuple pattern *).

Inductive es : Set :=  (*r liste d'expressions *)
 | Esone_exp (e5:e)
 | Escons_exps (e5:e) (es5:es).

Inductive eqn : Set :=  (*r Ã©quation *)
 | EqDef (y:identifier) (ck5:ck) (ce:cexp) (*r expression *)
 | EqFby (y:identifier) (ck5:ck) (k:constant) (e5:e) (*r fby *)
 | EqApp (ys:xs) (ck5:ck) (f:identifier) (es5:es) (*r application *)
 | EqEval (y:identifier) (ck5:ck) (h5:h) (e0:e) (_:list e) (*r application de fonction OCaml *).

Inductive leqns : Set :=  (*r list of equations *)
 | Eqseqs_one (eqn5:eqn)
 | Eqseqs_cons (eqn5:eqn) (eqns:leqns).



Definition C : Set := list (string*ck).

Inductive nodedef : Set :=  (*r node definition *)
| Nodemk_node (f:identifier) (xs5:xs) (ys:xs) (eqns:leqns).


Definition program : Set := list (C * nodedef).

Lemma eq_ck: forall (x y : ck), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_ck : ott_coq_equality.

Inductive sign : Set :=  (*r node signature *)
 | Signcons (xs5:xs) (ck5:ck) (ys:xs) (ck':ck).

Definition S : Set := list identifier.

Definition subst : Set := list (identifier * identifier).

Definition H : Set := list (string*sign).


Fixpoint assoc (x:string) (l: C) :=
  match l with
  | nil => None
  | cons (y,c) l => if eq_identifier x y then Some c else assoc x l
  end.


Fixpoint assoc_global (x:string) (l: H) :=
  match l with
  | nil => None
  | cons (y,c) l => if eq_identifier x y then Some c else assoc_global x l
  end.

(* subst x' --> y' in c *)
Fixpoint apply_subst c x' y' :=
	 match c with
	 | Ckbase => c
	 | Ckon c x => if eq_identifier x x' then
	      Ckon (apply_subst c x' y') y'
	   else
	      Ckon (apply_subst c x' y') x
	 | Ckonnot c x => if eq_identifier x x' then
	      Ckonnot (apply_subst c x' y') y'
	   else
	      Ckonnot (apply_subst c x' y') x
	 | Cktuple ck1 ck2 => Cktuple (apply_subst ck1 x' y') (apply_subst ck2 x' y')
	 | Ckarrow ck1 ck2 => Ckarrow (apply_subst ck1 x' y') (apply_subst ck2 x' y')
	 end.

(* apply all substs in s on c  *)
Fixpoint apply_substs s c :=
	 match s with
	 | nil => c
	 | cons (x, y) sigma' => apply_substs sigma' (apply_subst c x y)
	 end.


(** definitions *)

(** funs Carriers *)
Fixpoint carriers (x1:ck) : S:=
  match x1 with
  | Ckbase =>  nil
  | (Ckon ck5 x) =>  (cons  x    (carriers ck5 )  )
  | (Ckonnot ck5 x) =>  (cons  x    (carriers ck5 )  )
  | (Ckarrow ck1 ck2) =>  ( (  (carriers ck1 )  ) ++ (  (carriers ck2 )  ) )
  | (Cktuple ck1 ck2) =>  ( (  (carriers ck1 )  ) ++ (  (carriers ck2 )  ) )
end.

(** definitions *)

(** funs Subst_base *)
Fixpoint subst_ck (x1:ck) (x2:ck) : ck:=
  match x1,x2 with
  | Ckbase , ck' => ck'
  |  (Ckon ck5 x)  , ck' => (Ckon   (subst_ck ck5 ck' )   x)
  |  (Ckonnot ck5 x)  , ck' => (Ckonnot   (subst_ck ck5 ck' )   x)
  |  (Ckarrow ck1 ck2)  , ck' => (Ckarrow   (subst_ck ck1 ck' )     (subst_ck ck2 ck' )  )
  |  (Cktuple ck1 ck2)  , ck' => (Cktuple   (subst_ck ck1 ck' )     (subst_ck ck2 ck' )  )
end.

(** definitions *)

(* defns Substs_exp *)
Inductive Sub_clk_subst_exp : xs -> es -> S -> subst -> Prop :=    (* defn clk_subst_exp *)
 | Sub_E_unit : forall (ck5:ck) (S5:S),
     Sub_clk_subst_exp Patp_nil (Esone_exp (Eunit ck5)) S5  nil
 | Sub_E_in : forall (x y:identifier) (S5:S),
      ( In  x   S5  )  ->
     Sub_clk_subst_exp (Patp_var x) (Esone_exp (Evar y)) S5  (cons ( x , y ) nil)
 | Sub_E_notin : forall (x:identifier) (e5:e) (S5:S),
      (~ In  x   S5  )  ->
     Sub_clk_subst_exp (Patp_var x) (Esone_exp e5) S5  nil
 | Sub_E_list : forall (y:identifier) (ys:xs) (e5:e) (es5:es) (S5:S) (s s':subst),
     Sub_clk_subst_exp (Patp_var y) (Esone_exp e5) S5 s ->
     Sub_clk_subst_exp ys es5 S5 s' ->
     Sub_clk_subst_exp (Patp_tuple y ys) (Escons_exps e5 es5) S5  (app  s   s' ) .
(** definitions *)

(* defns Substs_pat *)
Inductive Sub_clk_subst_pat : xs -> xs -> S -> subst -> Prop :=    (* defn clk_subst_pat *)
 | Sub_V_nil : forall (S5:S),
     Sub_clk_subst_pat Patp_nil Patp_nil S5  nil
 | Sub_V_in : forall (y y':identifier) (S5:S),
      ( In  y   S5  )  ->
     Sub_clk_subst_pat (Patp_var y) (Patp_var y') S5  (cons ( y , y' ) nil)
 | Sub_V_notin : forall (y y':identifier) (S5:S),
      (~ In  y   S5  )  ->
     Sub_clk_subst_pat (Patp_var y) (Patp_var y') S5  nil
 | Sub_V_list : forall (y:identifier) (ys:xs) (y':identifier) (ys':xs) (S5:S) (s s':subst),
     Sub_clk_subst_pat (Patp_var y) (Patp_var y') S5 s ->
     Sub_clk_subst_pat ys ys' S5 s' ->
     Sub_clk_subst_pat (Patp_tuple y ys) (Patp_tuple y' ys') S5  (app  s   s' ) .
(** definitions *)

(* defns Clk_exp *)
Inductive clk_lexp : C -> e -> ck -> Prop :=    (* defn clk_lexp *)
 | Unit : forall (C5:C) (ck5:ck),
     clk_lexp C5 (Eunit ck5) ck5
 | Const : forall (C5:C) (k:constant) (ck5:ck),
     clk_lexp C5 (Econst k ck5) ck5
 | Constr : forall (C5:C) (X:type_constr) (ck5:ck),
     clk_lexp C5 (Econstructor X ck5) ck5
 | Var : forall (C5:C) (x:identifier) (ck5:ck),
      (assoc  x   C5  = Some  ck5 )  ->
     clk_lexp C5 (Evar x) ck5
 | Unop : forall (C5:C) (unop5:unop) (e5:e) (ck5:ck),
     clk_lexp C5 e5 ck5 ->
     clk_lexp C5 (Eunop unop5 e5) ck5
 | Binop : forall (C5:C) (e5:e) (binop5:binop) (e':e) (ck5:ck),
     clk_lexp C5 e5 ck5 ->
     clk_lexp C5 e' ck5 ->
     clk_lexp C5 (Ebinop e5 binop5 e') ck5
 | When : forall (C5:C) (e5:e) (x:identifier) (ck5:ck),
     clk_lexp C5 e5 ck5 ->
     clk_lexp C5 (Evar x) ck5 ->
     clk_lexp C5 (Ewhen e5 x) (Ckon ck5 x)
 | Whennot : forall (C5:C) (e5:e) (x:identifier) (ck5:ck),
     clk_lexp C5 e5 ck5 ->
     clk_lexp C5 (Evar x) ck5 ->
     clk_lexp C5 (Ewhennot e5 x) (Ckonnot ck5 x)
with clk_es : C -> es -> ck -> Prop :=    (* defn clk_es *)
 | One_E : forall (C5:C) (e5:e) (ck5:ck),
     clk_lexp C5 e5 ck5 ->
     clk_es C5 (Esone_exp e5) ck5
 | Cons_E : forall (C5:C) (e5:e) (es5:es) (ck5 ck':ck),
     clk_lexp C5 e5 ck5 ->
     clk_es C5 es5 ck' ->
     clk_es C5 (Escons_exps e5 es5) (Cktuple ck5 ck').
(** definitions *)

(* defns Clk_cexps *)
Inductive clk_cexp : C -> cexp -> ck -> Prop :=    (* defn clk_cexp *)
 | Exp : forall (C5:C) (e5:e) (ck5:ck),
     clk_lexp C5 e5 ck5 ->
     clk_cexp C5 (Ceexp e5) ck5
 | Merge : forall (C5:C) (x:identifier) (ce ce':cexp) (ck5:ck),
     clk_lexp C5 (Evar x) ck5 ->
     clk_cexp C5 ce (Ckon ck5 x) ->
     clk_cexp C5 ce' (Ckonnot ck5 x) ->
     clk_cexp C5 (Cemerge x ce ce') ck5
 | If : forall (C5:C) (e5:e) (ce ce':cexp) (ck5:ck),
     clk_lexp C5 e5 ck5 ->
     clk_cexp C5 ce ck5 ->
     clk_cexp C5 ce' ck5 ->
     clk_cexp C5 (Ceif e5 ce ce') ck5
with Clk_pat : C -> xs -> ck -> Prop :=    (* defn Clk_pat *)
 | NNil : forall (C5:C),
     Clk_pat C5 Patp_nil Ckbase
 | NVariable : forall (C5:C) (y:identifier) (ck5:ck),
      (assoc  y   C5  = Some  ck5 )  ->
     Clk_pat C5 (Patp_var y) ck5
 | NList : forall (C5:C) (y:identifier) (ys:xs) (ck5 ck':ck),
     clk_lexp C5 (Evar y) ck5 ->
     Clk_pat C5 ys ck' ->
     Clk_pat C5 (Patp_tuple y ys) (Cktuple ck5 ck')
with clk_global_var_clocks : H -> identifier -> xs -> ck -> xs -> ck -> S -> Prop :=    (* defn clk_global_var_clocks *)
 | Sign : forall (H5:H) (f:identifier) (xs5:xs) (ck5:ck) (ys:xs) (ck':ck) (S5:S),
      (assoc_global  f   H5  = Some  (Signcons xs5 ck5 ys ck') )  ->
      S5  =   ( (  (carriers ck5 )  ) ++ (  (carriers ck' )  ) )   ->
     clk_global_var_clocks H5 f xs5 ck5 ys ck' S5
with clk_inst : ck -> ck -> es -> xs -> ck -> xs -> ck -> xs -> ck -> S -> Prop :=    (* defn clk_inst *)
 | Inst : forall (ck1 ck2:ck) (es5:es) (ys:xs) (ck_5:ck) (xs5:xs) (ck1':ck) (ys':xs) (ck2':ck) (S5:S) (s1 subst5 s2:subst),
     Sub_clk_subst_exp xs5 es5 S5 s1 ->
      ck1  = (apply_substs  s1    (subst_ck ck1' ck_5 )  )  ->
     Sub_clk_subst_pat ys' ys S5 s2 ->
      ck2  = (apply_substs   (app  s2   s1 )     (subst_ck ck2' ck_5 )  )  ->
     clk_inst ck1 ck2 es5 ys ck_5 xs5 ck1' ys' ck2' S5
with Well_clocked_eq : H -> C -> eqn -> Prop :=    (* defn Well_clocked_eq *)
 | App : forall (H5:H) (C5:C) (ys:xs) (ck_5:ck) (f:identifier) (es5:es) (xs5:xs) (ck1':ck) (ys':xs) (ck2':ck) (S5:S) (ck1 ck2:ck),
     clk_global_var_clocks H5 f xs5 ck1' ys' ck2' S5 ->
     clk_inst ck1 ck2 es5 ys ck_5 xs5 ck1' ys' ck2' S5 ->
     clk_es C5 es5 ck1 ->
     Clk_pat C5 ys ck2 ->
     Well_clocked_eq H5 C5 (EqApp ys ck_5 f es5)
 | Expr : forall (H5:H) (C5:C) (y:identifier) (ck5:ck) (ce:cexp),
     Clk_pat C5 (Patp_var y) ck5 ->
     clk_cexp C5 ce ck5 ->
     Well_clocked_eq H5 C5 (EqDef y ck5 ce)
 | Fby : forall (H5:H) (C5:C) (y:identifier) (ck5:ck) (k:constant) (e5:e),
     Clk_pat C5 (Patp_var y) ck5 ->
     clk_lexp C5 e5 ck5 ->
     Well_clocked_eq H5 C5 (EqFby y ck5 k e5)
 | Call : forall (e_list:list e) (H5:H) (C5:C) (y:identifier) (ck5:ck) (h5:h) (e_5:e),
     Clk_pat C5 (Patp_var y) ck5 ->
     clk_lexp C5 e_5 ck5 ->
     (forall e_, In (e_) (map (fun (e_ : e) => (e_)) e_list) -> (clk_lexp C5 e_ ck5)) ->
     Well_clocked_eq H5 C5 (EqEval y ck5 h5 e_5 e_list)
with Well_clocked_eqns : H -> C -> leqns -> Prop :=    (* defn Well_clocked_eqns *)
 | OneEqn : forall (H5:H) (C5:C) (eqn5:eqn),
     Well_clocked_eq H5 C5 eqn5 ->
     Well_clocked_eqns H5 C5 (Eqseqs_one eqn5)
 | ConsEqns : forall (H5:H) (C5:C) (eqn5:eqn) (eqns:leqns),
     Well_clocked_eq H5 C5 eqn5 ->
     Well_clocked_eqns H5 C5 eqns ->
     Well_clocked_eqns H5 C5 (Eqseqs_cons eqn5 eqns).
(** definitions *)

(* defns Well_clocked_node *)
Inductive Well_clocked_node : H -> C -> nodedef -> sign -> Prop :=    (* defn Well_clocked_node *)
 | Node : forall (H5:H) (C5:C) (f:identifier) (xs5 ys:xs) (eqns:leqns) (ck5 ck':ck),
     Well_clocked_eqns H5 C5 eqns ->
     Clk_pat C5 xs5 ck5 ->
     Clk_pat C5 ys ck' ->
     Well_clocked_node H5 C5 (Nodemk_node f xs5 ys eqns) (Signcons xs5 ck5 ys ck').
(** definitions *)

(* defns Well_clocked_prog *)
Inductive Well_clocked_nodes : H -> program -> Prop :=    (* defn Well_clocked_nodes *)
 | EmptyProg : forall (H5:H),
     Well_clocked_nodes H5  nil
 | ConsProg : forall (H5:H) (C5:C) (f:identifier) (xs5 ys:xs) (eqns:leqns) (nodes:program) (sign5:sign),
     Well_clocked_node H5 C5 (Nodemk_node f xs5 ys eqns) sign5 ->
     Well_clocked_nodes  (cons ( f , sign5 )  H5 )  nodes ->
     Well_clocked_nodes H5  (cons ( C5 , (Nodemk_node f xs5 ys eqns) )  nodes ) .
